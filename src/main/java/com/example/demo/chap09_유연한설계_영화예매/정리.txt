* 추상화

로버트 파틴은 확장 가능하고 변화에 유연하게 대응할 수 있는 설계를 만들 수 있는 개방 폐쇄 원칙을 고안했다.
개방-폐쇄 원칙은 확장에 대해 열려있고 수정에 닫혀있어야한다.
애플리케이션의 요구사항이 변경될 때 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있고
기존의 '코드'를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있는것이다.

개방-폐쇄 원칙은 런타임 의존성과 컴파일타임 의존성에 관한 이야기다.

개방-폐쇄 원칙은 '추상화'에 '의존'하는 것이다. 
추상화란 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법이다.
추상화 과정을 통해 문맥이 바뀌더라도 바뀌지 않는 공통적인 부분만 남게되고 변하는 부분생략된다.
생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
추상화 부분(공통적인 부분)이 수정에 대해 닫혀있고 생략된 부분은 확장의 여지를 남긴다. 이것은 추상화가 개방-폐쇠 원칙을 가능하게 만드는 이유이다.

하지만 단순히 추상화를 했다고 수정에 대해 닫혀있는것은 아니다. 개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성이다. 
수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야한다.
올바른 추상화를 설계하고 추상화에 대해서만 의존하도록 관계를 제한함으로써 설계를 유연하게 확장할 수 있다.

개방-폐쇄 원칙을 지키기 위해 생성과 사용을 분리해야한다. 
생성과 사용은 객체A가 B의 인터페이스를 의존할 때 B의 인터페이스의 구체(구현) 클래스를 A객체 안에서 생성하고 사용하는 것이다.
직접 생성을 하게되면 구체 클래스에 지식(정보의 양)이 많아지게되어 결합도가 높아진다. 결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조로 설계하기 어려워진다.
(B의 동작을 추가하기위해 A의 기존 코드를 수정해야한다.) 생성의 적절한 위치는 PURE FABRICATION 이다.
=============================================================================================
크레이그 라만은 시스템을 객체로 분해하는 두 가지 방식이 존재한다고 설명한다.
한 가지는 표현적 분해로 사물 또는 개념을 표현을 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.
표현적 분해는 객체지향 설계를 위한 가장 근본적인 접근법이다.
다음은 행위적 분해로 어떤 행동을 추가하려하는대 이 행동이 책임질 마땅한 도메인 개념이 존재하지 않을다면 PURE FABRICATION(순수한 가공물)을 추가하고
이 객체에게 책임을 할당한다.
=============================================================================================
의존성 해결 방법은 의존성 주입, SERVICE LOCATOR 패턴이 있다.

사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 의존성 주입이있다.
의존성 주입은 컴파일타임 의존성, 런타임 의존성의 차이점을 이용하고 생성자 주입, setter 주입, 메서드 주입의 방법이있다.

서비스 로케이터는 객체가 직접 서비스 로케이터에게 의존성을 해결해줄 것을 요청한다.
이 패턴의 가장 큰 단점은 의존성을 감추는 것이다. A의 객체가 의존하는 퍼블릭 인터페이스가 어디에도 의존성에 대한 정보가 표시돼 있지 않아서 사용할 때 불안전하다.
의존성 대상을 설정하는 시점과 의존성이 해결되는 시점을 멀리 떨어트려 놓으면 코드를 이해하고 디벙깅하기 어렵다.
=============================================================================================
A클래스가 구체 클래스에 의존성하고있다고 가정하자.
A클래스는 가격을 계산하라는 높은 수준의 개념을 구현하고 구체 클래스 내부에 금액을 얼마만큼 할인해주는지 더 구체적인 수준의 매커니즘을 담당하고 있다.
여기서 A객체는 상위 수준 클래스이고 구체 클래스는 하위 수준 클래스된다. 문제는 상위 수준 클래스가 하위 수준 클래스를 의존하는 것이다.
객체 사이의 협력의 본질을 담고 있는 것은 상위 수준의 정책이다. 의존은 변경을 의미한다. 하위 수준의 변경이 상위 수준 클래스 변경이 전파될 수 있다.
변경의 영향이 최소화할 수 있도록 의존성을 관리해줘야한다. 해결방법은 추상화이다. 추상화에 의존하도록하면 하위 수준 클래스의 변경이 상위 수준 클래스에 전파되지
않도록 방지할 수 있다.

정리하자면
1. 상위 수준의 모듈이 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야한다.
2. 추상화는 구체적인 사항에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야한다.
이를 의존성 역전 원칙이라고한다. 최초로 착안한 로버트 마틴은 '역전'이라는 단어를 사용한 이유에 의존성 역전 원칙을 따르는 설계는 의존성 방향이
전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문이라고 설명했다.
=============================================================================================
중요한것은 역할, 책임, 협력이다.
유연한 설계는 항상 옭은것은 아니다. 설계의 미덕은 단순함과 명확함이다. 단순하고 명확한 설계는 읽기 쉽고 이해하기도 편하다.
반대로 유연한 설계는 변경하기 쉽고 확장하기 쉬운 구조이지만 단순함과 명확함의 미덕을 버리게 될 가능성이 높다.

유연한 설계는 항상 복잡성을 수반한다. 복잡성은 필요한 이유와 합리적인 근거를 제시해야만 한다. 아니면 누구도 설계가 만족스럽지 않을 것이다.

유연한 설계를 위해 의존성을 설명했지만 설계를 유연하게 만들기 위해서는 협력에 참여하는 객체간에 어떤 메시지를 전송하는지가 중요하다.
설계를 유연하게 만들기 위해서는 먼저 역할, 책임, 협력을 맞춰야한다. 협력을 재사용할 필요가 없다면 설계를 유연하게 만들 필요가없다.

초보자가 저지르는 실수 중에 하나가 역할과 책임이 자리를 잡기 전에 성급하게 생성에 집중하는 것이다. 객체 생성 매커니즘은 마지막에 하는 것이좋다.
우선이 되야할 것은 비즈니스 로직을 처리하기 위해 책임을 할당하고 협력에 균형을 맞춰야한다.








