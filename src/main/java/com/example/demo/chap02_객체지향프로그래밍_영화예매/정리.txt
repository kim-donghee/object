* 객체지향, 객체, 객체는 공동체(협력), 다형성
======================================================================================================
객체지향 패러다임을 얻기 위해서는 클래스가 아닌 객체에 초점을 맞춰야한다.
 
객체지향 프로그래밍을 하기위해 두 가지에 집중해야한다.
1. 어떤' 클래스'가 필요한지를 고민하기 전에 어떤 '객체'들이 필요한지 고민한다.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 '공동체'의 일원으로 봐야한다.

자율적인 객체는 두 가지 중요한 사실을 알아햐한다.
1. 객체는 상태와 행동을 함께 가지는 복합적인 존재다.
2. 객체가 스스로 판단하고 행동하는 자율적인 존재다.

데이터와 기능을 객체 내부로 함께 묶는 것은 캡슐화라고한다. 객체지향 프로그래밍은 캡슐화된 객체를 접근 제어를 사용해서 외부에서 접근을 통제해야한다.
객체 내부에 접근을 통제하는 이유는 스스로 상태를 관리, 판단, 행동하는 자율적인 존재로 만들기 위해서다.

캡슐화와 접근 제어는 객체를 두 부분으로 나눈다.
1. 외부에서 접근 가능한 '퍼블릭 인터페이스'
2. 외부에서는 접근 불가능하고 오직 내부에서만 접근 가능한 '구현'
이렇게 나누는 것을 '인터페이스와 구현의 분리'원칙이라고 부른다. 훌륭한 객체지향 프로그래밍을 위해 따라야할 핵심 원칙이다.
'퍼블릭 인터페이스'는 public으로 지정된 메서드만 포함된다.
'구현'은 private 메서드나 protected 메서드, 속성이다.

설계가 필요한 이유는 변경을 관리하기 위해서다. 객체지향 언어는 객체 사이의 의존성을 적절히 관리함으로써 변경에 대한 파급효과를 제어할 수 있다.
'변경될 가능성이 있는 세부적인 구현 내용을 private 영역' 안에 감춤으로써 변경으로 인한 혼란을 최소화할 수 있다.
======================================================================================================
객체 내부의 상태는 외부에서 접근하지 못하도록 하고 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 한다.
객체는 공개된 행동에 요청하고 요청 받은 객체는 자율적으로 요청을 처리하고 응답해야한다. 객체간의 상호작용은 오직 메시지 전송, 수신 만으로 할 수 있다.
수신된 메시지를 메서드라고 부른다. 

'메시지와 메서드의 구분에서 부터 다형성은 시작된다.'
======================================================================================================
컴파일 시점 의존성과 실행 시간 의존성
'컴파일 시점 의존성'은 컴파일 시점에 클래스의 의존성이다.
'실행 시간 의존성'은 실제 실행 시점에 객체의 의존성이다.

클래스의 의존성과 실행 시점의 의존성은 상속과 다형성을 이용하면 다른 의존성을 가지게 할 수 있다.
다형성을 이용하면 이처럼 유연하고 쉽게 재사용할 수 있고 확장 가능한 객체지향 설계를 만들 수 있다.

하지만 설계가 유연해지면 재사용성과 확장 가능성이 높아지지만 코드의 이해와 디버깅이 어려워진다.
반대로 유연성을 억제하면 코드는 이해하고 디버깅이 쉬워지고 재사용성과 확장 가능성은 떨어진다.
======================================================================================================
차이에 의한 프로그래밍는 부모 클래스에 다른 부분만 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법이다.
이를 가능하게 해주는 것이 상속이다. 상속은 객체지향 코드를 재사용하기 위해 가장 널리 사용되는 방법으로 속성과 행동을 모두 물려받는다.

다형성이란 동일한 메시지를 전송하지만 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다.
이게 가능한 이유는 실행되는 '메서드가 컴파일 시점이 아닌 실행 시점에 결정되기 때문이다.' 이를 '지연' 또는 '동적' 바인딩이라고한다.
'컴파일 시점'에 함수 또는 프로시저를 결정하는 것을 '초기' 또는 '정적' 바인딩이라고한다.

클래스들의 공통으로 가질 수 있는 인터페이스를 정의하면 추상 클래스(구현 일부), 인터페이스(구현 전체)로 추상화 할 수 있다.

추상화는 두 가지 장점을 가진다.
1. 추상화의 계층만 뗴어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
2. 좀더 유연한 설계를 할 수 있다.(상위 정책을 표현하면 기존 구조를 수정하지 않고도 새로운 기능을 쉽게 추가하고 확장할 수 있다.

정책이 바뀌어 애플리케이션을 확장할 때 트레이드오프를 통해 설계를 생각해보자.
======================================================================================================
상속은 코드의 재사용성을 높이기 위한 수단이다. 하지만 코드의 재사용성 위함이면 합성사용하는 것이 더 좋다.

상속은 두 가지 관점에서 안 좋은 영향을 준다.
1. 상속은 캡슐화를 위반한다. (상속은 자식, 부모 클래스간에 강하게 결합되어 변경을 어렵게 만든다.)
2. 설계를 유연하지 못하게 만든다.
(실행 시점에 정책은 변경할 경우 인스턴스 자체를 변경하는 문제가 발생한다. 합성 방법을 이용하면 실행 시점에 자신의 인스턴스 변수를 메서드를 통해 수정하면된다.)

합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하고 내부에 구현에 대해서는 전혀알지 못하는 것으로 약한 결합을 얻을 수 있다. (상속의 두 가지 단점도 해결된다.)

하지만 다형성을 위해 인터페이스를 재사용하는 경우 상속과 합성을 함께 조합해서 사용하는 것이 좋다.
======================================================================================================


