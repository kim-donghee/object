* 타입, 타입 계층 
======================================================================================================
상속은 재사용의 목적과 타입 계층을 구현하기 위해 사용된다.
재사용의 경우에는 부모 클래스와 자식 클래스 간에 결합도가 높아지기 때문에 피해야한다.
타입 계층을 구현하기 위해 주로 사용되야한다. 타입 계층은 동일한 메시지에 대해 서로 다르게 행동을 할 수 있는 다형적인 객체를 구현하기 위함이다.
객체지향 프로그래밍의 타입을 이해하려면 타입과 개념 관점의 타입을 이해햐아한다.
======================================================================================================
개념 관점의 타입은 공통의 특징을 공유하는 대상을 분류한 것이다.
프로그래밍 언어 관점에서 타입은 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.

위에 두 개의 관점을 조합한 타입은 동일한 특징(오퍼레이션)을 제공하는 것이다. 

객체지향 프로그래밍 관점에서 타입을 다음과 같이 정의할 수 있다.
'객체의 퍼블릭 인터페이스는 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류한다.'
======================================================================================================
수학에서 집합은 다른 집합을 포함할 수 있다. 타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다.
타입 안에 포함된 객체들을 좀 더 상세한 기준으로 묶어 새로운 타입을 정의하면 새로운 타입은 자연스럽게 기존 타입의 부분 집합이된다.
-------------------------------------------------------------------------
예를 들어 자바, C++, 루비, 자바스크립트, 셀프, C, 파스칼은 '프로그래밍 언어' 타입의 '인스턴스'일 떄
'프로그래밍 언어' 집합 안에 자바, C++, ... 이 원소로 표현할 수 있다.

'프로그래밍 언어'를 더 세분화를 하면

자바, 루비, 자바스크립트, ...는 '객체지향 언어' / C, 파스칼은 '절차적 언어'언어로 분류할 수 있다.

'객체지향 언어'를 더 세분화를 하면
자바, C++, 루비는 클래스 기반 / 자바스크립트, 셀프는 프로토타입으로 분류할 수 있다.
-------------------------------------------------------------------------
프로그래밍 언어(다른 타입을 포함하는 타입)은 객체지향 언어(포함 되는 타입)보다 더 일반화된 의미릴 표현할 수 있다. 반대로 객체지향 언어(포함되는 타입은) 좀 더 특수하고 구체적이다.

포함하는 타입은 외연 관점에서 더 크고 내연 관점에서는 더 일반적이다. 반대로 포함되는 타입은 외연 관점에서 더 작고 내연 관점에서 더 특수하다. 
이것은 포함 관계로 연결된 타입 사이에 개념적으로 일반화와 특수화 관계가 존재한다는 것을 의미한다.

* 외연(extension) : 타입에 속하는 객체들의 집합
* 내연(intension) : 객체들이 공유하는 속성, 행동의 집합

일반화와 특수화 관계는 타입 계층 구조를 표현할 수 있다.
타입 계층을 구성하는 타입 간의 관계에서 일반적인 타입을 '슈퍼 타입', 특수한 타입을 '서브 타입'이라고 부른다.

슈퍼 타입 
집합이 다른 집합의 모든 멤버를 포함한다. 
타입 정의가 다른 타입보다 좀 더 일반적이다.

서브 타입
집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
타입 정의가 다른 타입보다 좀 더 구체적이다.
======================================================================================================
타입을 구현하기 위한 일반적인 방법은 클래스를 이용하는 것이고 타입 계층을 구현하는 일반적인 방법은 상속이다.

상속은 재사용 목적으로 사용하면 문제가 발생할 수 있다. 상속의 올바른 용도는 타입 계층을 구현하는 것이다. 어떤 조건에 상속을 사용해야 될까?
마틴 오더스키는 두 가지 질문에 만족할 때 상속을 사용하라고한다.
1. 상속 관계가 is-a 관계를 모델링하는가?
'자식 클래스'가 '부모 클래스'라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주한다.

*is-a 관계는 'S타입이 T타입의 일종이라면 S is-a T라고 말할 수 있어야한다.' 이다 . is-a 관계는 직관적이고 명쾌하지는 않다.
새는 날 수 있다. 펭귄은 새다. 펭귄은 새지만 날 수 없기때문에 상속을 적용하면안된다.
is-a 관계는 상속을 사용할 후보로만 둬야한다.

2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가?
클라이언트 입장에서 부모 클래스와 자식 클래스 사이의 차이점을 몰라야한다. 이를 자식 클래스와 부모 클래스 사이의 '행동 호환성'이라고 부른다.

* 행동 호환성은 클라이언트의 관점에서 상속 계층의 두 타입 사이에 행동이 호환될 경우에만 타입 계층을 묶어야한다.

'팽귄은 새다'의 상속 관계를 유지하기 위해 3가지 방법을 시도해볼 수 있다.
1. 펭귄.fly()을 오버라이딩해서 내부 구현을 비운다.
이 방법은 클라이언트 관점에서 기대를 만족시키지 못하기때문에 올바른 설계가 아니다.
2. 예외를 던진다.
이 방법 또한 클라이언트 관점에서 만족하지 못한다.
3. 인자로 새의 타입을 받아서 펭귄이 아닐 경우에만 실행한다.
이 방법은 타입을 체크해야한다. 새로운 날지 못하는 새의 타입이 생길때마다 수정해야한다. 개방-폐쇄 원칙을 위반한다.

해결 방법은 클라이언트의 기대에 맞게 상속 계층을 분리하는 것이다.
새와 펭귄 문제는 새와 날 수 있는새로 상속 계층을 분리하면된다.

클라이언트에 따라 인터페이스를 분리할 수 도 있다.
fly 오퍼레이션을 가진 Flyer 인터페이스, walk 인터페이스를 가진 Walker 인터페이스로 분리해서 자신이 수행할 수 있는 인터페이스만 구현하게 할 수 있다.
Bird가 Flyer 인터페이스와 Walker 인터페이스를 구현하고 client1은 Flyer에 의존하고 Client2는 Walker에 의존한다고 가정하자.

client1의 요구사항이 바뀌어 Flyer 인터페이스가 변경되어도 Flyer에 의존하고 있는 Bird에게만 영향을 받게된다.
client2는 Flyer나 Bird에 대해 전혀 알지 못하기 때문에 영향을 받지 않는다.

인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙을 '인터페이스의 분리 원칙'이라고 부른다. 
======================================================================================================
상속의 목적은 재사용과 타입 계층을 위함이다. 재사용의 목적을 서브클래싱, 타입 계층의 목적을 서브타이핑이라고한다.

서브클래싱 : 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우를 가리키며 부모 클래스와 자식 클래스간의 행동이 호환되지 않는다.
구현상속, 클래스 상속이라고도 부른다.

서브타이핑 : 타입 계층을 구성하기 위해 상속을 사용하는 경우를 가르키며 부모 클래스와 자식 클래스간의 호환되어야한다.
인터페이스 상속이라고도 부른다.
======================================================================================================
바바라 리스코프는 올바른 상속 관계의 특징을 정의하기 위해 '리스코프 치환 원칙'을 발표했다.
리스코프 치환 원칙은 서브타입을 기반 타입에 대해 대체 가능해야하고 '클라이언트'는 인식하지 못해야한다.

클라이언트가 어떤 자식 클래스와도 안정적으로 협력할 수 있는 상속 쿠조를 구현할 수 있는 가이드라인을 제공한다.
새로운 자식 클래스가 추가되어도 클라이언트 입장에서 동일하게 행동하기만 한다면 클라이언트를 수정하지 않고도 상속 계층을 확장할 수 있다.

리스코프 치환 원칙을 따르는 설계는 유연할뿐만 아니라 확장성도 높다.

자식 클래스가 클라이언트의 관점에서 부모 클래스를 대체할 수 있다면 기능 확장을 위해 자식 클래스를 추가하더라도 코드를 수정할 필요가 없어진다. 따라서
'리스코프 치환 원칙'은 '개방-폐쇄 원칙'을 만족하는 설계를 위한 전제 조건이다.
======================================================================================================
클라이언트와 서버 사이의 협력을 의무와 이익으로 구성된 계약의 관점에서 표현하는 것을 계약의 의한 설계라고 한다.

정상적으로 메서드를 실행하기 위해 사전조건, 클라이언트에게 보장해야하는 사후조건, 메서드 실행 전후로 인스턴스가 만족해야하는 클래스 불변식 3 가지 요소로 구성된다.

서브 타입에 더 강력한 사전 조건을 정의할 수 없다. 더 약하거나 같은 조건을 정의할 수 있다.
서브 타입에 더 강력하거나 같은 사후 조건을 정의할 수 있다. 더 약한 조건을 가질 수 없다.

======================================================================================================



