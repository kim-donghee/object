* 디자인 패턴, 프레임워크, 제어 역전
======================================================================================================
어떤 요구사항을 해결하기 위해 경험했던 유사한 방법을 다시 사용하는 경우가 있다. 이처럼 소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 
수 있는 해결 방법을 디자인 패턴이라고한다. 디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 '설계의 묶음'이다.

패턴이란 무엇인가를 논의할 때면 반복적으로 언급되는 몇 가지 핵심이 있다.
1. 패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다.
2. 패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통할 수 있다.
3. 패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다.
4. 패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.

패턴으로 인정받기 위한 '3의 원칙'이 있다.
1. 패턴은 이론이나 원칙이 아닌 실무에서 탄생한 것이다. 실무 경험이 적은 초보자여도 패턴을 반복적으로 익히면 유연하고 품질 높은 소프트웨어를 개발하는 방법을 익힐 수 있다.
2. 구현에 대한 장황한 대화가 아닌 패턴의 이름으로 높은 수준의 대화가 가능해야한다.
3. 패턴의 범위가 소프트웨어 개발과 직접적인 연관성을 가진 분석, 설계, 구현 영역만으로 한정된것이 아니다.
요구 사항을 관리하는 방법과 반복적인 규칙을 발견할 수 있는 모든 영역이 패턴의 대상이 될 수 있다.

패턴 4가지로 분류할 수 있다.
1. 특정한 설계 문제를 해결하는 것을 목적인 디자인 패턴
2. 소프트웨어의 전체적인 구조를 결정하는 아키텍처 패턴
3. 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴으로 이디엄
4. 디자인 패턴, 아키텍처 패턴, 이디엄은 기술적인 문제를 해결하는 데 초점을 맞추고 있다면 '분석 패턴'은 도메인 내의 개념적인 문제해결에 초점을 맞추고 있다.

객체지향 설계에서 가장 중요한 것은 올바른 책임을 올바른 객체에게 할당하고 객체 간의 유연한 협력 관계를 구축하는 일이다.
책임과 협력의 윤곽은 캡슐화, 크기, 의존성, 유연성, 성능, 확장 가능성, 재사용성 등의 다양한 요소들이 트레이드오프를 통해 결정된다. 책임과 협력을 결정하는 작업은 어려운일이다.
패턴은 역할, 책임, 협력의 템플릿이다. 패턴은 반복적으로 발생하는 문제를 해결하기 위해 사용할 수 있는 공통적인 역할과, 책임, 협력의 훌륭한 예제를 제공한다.
예) 
STRATEGY 패턴은 다양한 알고리즘을 동적으로 교체할 수 있는 역할과 책임의 집합을 제공한다.
BRIDGE 패턴은 추상화의 조합으로 인한 클래스의 폭발적인 증가 문제를 해결하기 위해 역할과 책임을 추상화와 구현의 두 개의 터다란 집합으로 분해함으로써 설계
확장 가능하게 만든다.
OBSERVER 패턴은 유연한 통지 메커니즘을 구축하기 위해 겍체 간의 결합도를 낮출 수 있는 역할과 책임의 집합을 제공한다.
위에 패턴들의 세부적인 사항들이 중요한 것이 아니다. 중요한 것은 패턴을 특정한 상황에 적용하면 손쉬게 역할과 책임, 협력 관계를 빠르고 손쉽게 구성할 수 있다.

패턴의 구성 요소는 클래스가 아닌 역할이다.
예)
COMPOSITE 패턴의 구성 요소 Component, Composite, Leaf는 클래스가 아닌 협력에 참여하는 객체들의 역할이다.
Component는 역할이기 때문에 Component가 제공하는 오퍼레이션을 구현하는 어떤 객체라도 Component가 될 수 있다.

패턴을 구성하는 요소가 클래스가 아니라 역할이라는 사실은 패턴 템플릿을 구현할 수 있는 다양한 방법이 존재한다는 사실을 암시한다.
역할을 동일한 오퍼레이션에 대해 응답할 수 있는 책임의 집합을 암시하기 떄문에 하나의 객체가 3 가지 역할 모두를 수행할 수 도 있다. 
반대로 다수의 클래스가 동일한 역할을 구현할 수 있다.

디자인 패턴의 구성요소가 클래스와 메서드가 아니라 역할과 책임이라는 사실을 이해하는 것이 중요하다.
어떤 코드가 디자인 패턴을 따른다고 할 때 역할, 책임, 협력의 관점에서 유사하성을 공유하는 것이지 특정한 규현 방식을 강제하는 것은 아니다.
디자인 패턴은 단지 역할, 책임, 협력의 템플릿을 제안할 뿐 구현 방법에 대해서는 제한하지 않는다.

------------------------------------------------------------------------------------------------------------
STRATEGY 패턴의 목적은 알고리즘 변경을 캡슐화하는 것이고 이를 구현하기 위해 객체 합성을 이용한다.
변경하는 부분과 변경하지 않는 부분으로 분리함으로써 변경을 캡슐화을 하는 상속을 사용할 수 도 있다. 
알고리즘을 캡슐화하기 위해 합성관계가 아닌 상속관계를 사용하면 TEMPLATE METHOD 패턴이된다.

TEMPLATE METHOD 패턴은 부모 클래스가 알고리즘의 기본 구조를 정의하고 구체적인 단계는 자식 클래스에서 정의함으로써 변경을 캡슐화할 수 있는 디자인 패턴이다.

STRATEGY 패턴과 TEMPLATE METHOD 패턴을 비교하면
상속이 합성보다 결합도가 높기때문에 런타임에 객체의 알고리즘을 변경하는 것은 불가능하다. 하지만 STRATEGY 패턴이 조금 더 복잡하다. 
------------------------------------------------------------------------------------------------------------
DECORATOR 패턴은 객체의 행동을 동적으로 추가할 수 있게 해주는 패턴으로서 기본적으로 객체의 행동을 결합하기 위해 객체 합성을 사용한다.
선택적인 행동의 개수와 순서에 대한 변경을 캡슐화할 수 있다.

COMPOSITE 패턴은 개별 객체와 복합 객체라는 객체의 수와 관련된 변경을 캡슐화는 것이 목적이다.
협력하는 객체의 수가 변경하더라도 사용하는 클라이언트에 영향을 미치지않는다.

'중복 할인 설계' COMPOSITE 패턴
'영화 예매 시스템' STRATEGY 패턴
'핸드폰 과금 시스템' DECORATOR 패턴
======================================================================================================
프레임워크란 '추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계' 또는
'애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격'을 의미한다.
첫 번째 정의는 구조적인 측면에 초점을 맞추고 두 번째 정의는 코드와 설계의 재사용이라는 목적에 초점을 맞춘 것이다.

프레임워크의 핵심은 추상 클래스나 인터페이스와 같은 추상화이다. 추상 클래스와 인터페이스가 가지는 어떤 특징이 프레임워크에 재사용성을 향상시킬까?

추상 클래스와 인터페이스가 '일관성 있는 협력을 만드는 핵심'이다. 
협력을 일관성 있고 유연하게 만들기 위해서는 추상화를 이용해 변경을 캡슐화하고
협력을 구현하는 코드 안의 의존성은 가급적이면 추상 클래스나 인터페이스와 같은 추상화를 향하도록 작성해야한다.
여기서 구체 클래스는 추상화에 의존하지만 추상화들은 구체 클래스에 의존하지 않게해야한다. 이것이 '의존성 역전 원칙'이다.
======================================================================================================
상위 정책을 재사용하는 것은 결국 도메인에 존재하는 핵심 개념들이 사이의 협력 관계를 사용한다는 것을 의미한다.
객체지향 설계의 재사용은 개별 클래스가 아니라 객체들 사이의 공통적인 협력 흐름으로부터 나온다. 그리고 
그 뒤에 항상 '의존성 역전 원리'라는 강력한 지원군이 존재한다. '의존성 역전 원리'는 '전통적인 설계 방법'과 '객체지향'을 구분하는 가장 핵심적인 원리이다.

의존성 역전 원리에 따라 구축되지 않은 시스템은 협력 흐름을 재사용할 수도 없으며 변경에 유연하게 대처할 수도 없다.

로버트 마틴은 훌륭한 객체지향 설계는 의존성이 역전된 설계라는 점을 강조했다.

의존성 역전 원리는 프레임워크의 가장 기본적인 설계 메커니즘이다. 의존성 역전은 의존성의 방향뿐만 아니라 제어 흐름의 주체 역시 역전시킨다.
따라서 프레임워크를 사용할 경우 개별 애플리케이션에서 프레임워크로 제어 흐름의 주체가 이동한다. 
이를 제어의 역전(Inversion of Control) 원리 또는 할리우드(Hollywood) 원리라고한다.

전체적인 협력의 흐름은 프레임워크에 정의돼 있다. 특정한 서브타입만 구현하면 프레임워크에 정의된 플로우에 따라 실행된다.

프레임워크에서는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다. 그리고 이렇게 완성되지 않은 채로 남겨진 동작을 훅이라고한다.
훅의 구현 방식은 애플리케이션의 컨텍스트에 따라 달라진다. 혹은 프레임워크 코드에서 호출하는 프레임워크의 특정 부분이다. 재정의된 훅은 제어 역전 원리에 따라
프레임워크가 원하는 시점에 호출된다.

협력을 제어하는 것은 프레임워크라는 것에 주목해야한다. 우리는 프레임워크가 적절한 시점에 실행할 것으로 예상되는 코드를 작성할 뿐이다.
과거의 우리가 라이브러리의 코드를 직접 호출했지만 객체지향의 시대에는 그저 프레임워크가 호출하는 코드를 작성해야만 한다.
제어가 우리에게서 프레임워크로 넘어가 버린 것이다. 다시 말해서 제어가 역전된 것이다.

제어의 역전이 프레임워크의 핵심 개념인 동시에 코드의 재사용을 가능하게 하는 힘이라는 사실을 이해해야한다.
======================================================================================================
