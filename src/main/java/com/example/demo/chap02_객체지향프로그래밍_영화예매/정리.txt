======================================================================================================
객체지향 프로그래밍
객체지향 패러다임을 얻기 위해서는 클래스가 아닌 객체에 초점을 맞춰야한다.
 
객체지향 프로그래밍을 하기위해 두 가지에 집중해야한다.
1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민한다.
2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.

자율적인 객체는 두 가지 중요한 사실을 알아햐한다.
1. 객체는 상태와 행동을 함께 가지는 복합적인 존재다.
2. 객체가 스스로 판단하고 행동하는 자율적인 존재다.
 
객체가 다른 객체에게 행동을 요청하고 객체는 자율적인 방법으로 응답을한다.
객체간의 상호작용은 메시지를 통해서한다. 메시지를 처리하기 위한 자율적인 방법이 메서드이다.
메시지와 메서드의 구분에서 부터 다형성이 개념이 출발한다.
 
외부에서 접근을 통제할 수 있게 접근 제어를 제공한다. 접근 제어를 위해 접근 수정자(public, protected, private)를 제공한다.
캡슐화와 접근 제어는 객체를 두 부분으로 나눈다. 외부에서 접근 가능한 퍼블릭 인터페이스, 외부에서 접근 불가능하고 내부만 접근 가능한 구현으로 나눈다. (인터페이스와 구현의 분리)
======================================================================================================
상속과 다형성을 이용하면 클래스 사이의 의존성과 객체 사이의 의존성은 동일하지 않다. 
다형성을 이용하면 유연하고 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계가 가지는 특징은 코드의 의존성과 실행 시점의 의존성이 다르다는 것이다.

설계가 유연해지면 재사용성과 확장 가능성이 높아지지만 코드이 이해와 디버깅이 어려워진다.
반대로 유연성을 억제하면 코드를 이해하고 디버깅하기가 쉬워지고 재사용성과 확장 가능성은 떨어진다.

추상 클래스(구현 일부), 인터페이스(구현 전체)는 실체화한 클래스에 추상화한 것이다.
추상화는 두 가지 장점을 가진다.
1. 추상화의 계층만 뗴어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
2. 좀더 유연한 설계를 할 수 있다.

정책이 바뀌어 애플리케이션을 확장할 때 트레이드오프를 통해 설계를 생각해보자.
======================================================================================================
상속은 코드의 재사용성을 높이기 위한 수단이다. 하지만 코드의 재사용성 위함이면 합성사용하는 것이 더 좋다.

상속은 두 가지 관점에서 안 좋은 영향을 준다.
1. 상속은 캡슐화를 위반한다. (상속은 자식, 부모 클래스간에 강하게 결합되어 변경을 어렵게 만든다.)
2. 설계를 유연하지 못하게 만든다.
(실행 시점에 정책은 변경할 경우 인스턴스 자체를 변경하는 문제가 발생한다. 합성 방법을 이용하면 실행 시점에 자신의 인스턴스 변수를 메서드를 통해 수정하면된다.)

합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하고 내부에 구현에 대해서는 전혀알지 못하는 것으로 약한 결합을 얻을 수 있다.
(상속의 두 가지 단점도 해결된다.)
하지만 다형성을 위해 인터페이스를 재사용하는 경우 상속과 합성을 함께 조합해서 사용하는 것이 좋다.
======================================================================================================
객체지향 패러다임의 관점에서 핵심은 역할, 책임, 협력이다.
객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 협력이라고한다.
협력에 참여하기 위해 수행하는 로직을 책임이라고 부른다.
책임들이 모여 객체가 수행하는 역할이라고한다.





