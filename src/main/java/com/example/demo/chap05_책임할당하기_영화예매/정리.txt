책임 주도 설계는 두 가지 원칙을 따라야 한다.
1. 데이터보다 행동을 먼저 결정하라.
이 객체에 어떤 데이터가 필요한지 결정한 후 데이터를 처리하기 위해 필요한 오퍼레이션은 무엇인지 결정하지말고
어떤 오퍼레이션이 필요한지 결정하고 책임을 수행하기 위한 데이터는 무엇인가를 결정하자.
2. 협력이라는 문맥안에서 책임을 결정하라.
책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야한다.
메시지 수신자가 아니라 메시지 전송자에게 적합한 책임을 부여하자.

책임 주도 설계
사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.
시스템 책임을 더 작은 책임으로 분할한다.
분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 책임질 적절한 객체 또는 역할을 찾는다.
해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력한다.

클래스는 하나 이상의 변경 이유를 가지면 응집도가 낮다고 한다. 변경 이유에 따라 클래스를 분리해야한다.
코드를 변경하는 이유를 파악하기 위한 방법은 두 가지가 있다.
1. 인스턴스 변수가 초기화되는 시점을 살펴본다. 인스턴스를 생성할 때 모든 속성을 함께 초기화하지 않으면 응집도가 낮다는 증거이다.
초기화되는 속성을 기준으로 코드를 분리해야한다.
2. 메서드들이 인스턴스 변수를 사용하는 방식을 살펴본다. 모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도가 높다고 볼 수 있다.
만약 메서드들이 사용하는 속성에 따라 그룹이 나뉜다면 클래스의 응집도가 낮다고 볼 수 있다.

하나의 클래스가 여러 타입의 행동을 구현하고 있는 것 처럼 보인다면 클래스를 분해하고 POLYMORPHISM(다형성) 패턴에 따라 책임을 분산시켜라.
예측 가능한 변경으로 인해 여러 클래스들이 불안정해진다면 PROTECTED VARIATIONS(변경 보호)패턴에 따라 안정적인 인터페이스 뒤로 변경을 캡슐화하라.

변경에 대비하는 두 가지 방법이있다.
1. 코드를 이해하고 수정하기 쉽도록 최대한 단순하게 설계하는 것이다. (상속)
2. 코드를 수정하지 않고도 변경을 수용할 수 있도록 코드를 더 유연하게 만드는 것이다. (합성)
대부분의 경우 상속이 더 좋은 방법이지만 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 상승해도 합성의 방법이 더 좋다.
예를 들어 할인 정책을 실행 중에 변경할 경우 상속의 경우에는 인스턴스를 생성하고 상태를 복사하고 식별자를 관리해야하지만
합성이 경우에는 할인 정책만 수정해주면 쉽게 변경할 수 있다.

책임과 객체 사이에서 방황할 때는 최대한 빠르게 목적한 기능을 수행하는 코드를 작성하고 올바른 책임을 부여하고 협력할 수 있도록 해주는것이다.
코드를 수정한 후에는 동작이 바뀌면 안되고 캡슐화를 시키고 높은 응집도와 낮은 결합도가 되도록해야한다. 이렇게 동작은 변경하지않고
내부 구조를 변경하는 것을 리팩토링이라고 한다.


