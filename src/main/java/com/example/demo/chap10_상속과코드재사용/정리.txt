* 상속, 상속의 단점, 캡슐화
======================================================================================================
객체지향에서의 클래스를 재사용하기 위해 새로운 클래스를 추가하는 가장 대표적인 기법은 상속이다.
재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가한다.
상속 외에도 코드를 효과적으로 재사용하는 방법으로 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 합성도 있다.
======================================================================================================
중복 코드란 요구 사항이 바뀔 때 함께 수정하는 코드다. 수정과 테스트 비용을 증가 시키기 때문에 제거해야한다.
중복 코드를 제거하기 위해 앤드류 헌트와 데이비트 토마스는 프로그래머들은 DRY(Don't Repeat Youreself)원칙을 따르라고한다.
DRY 원칙은 '동일한 지식을 중복하지 말라'이다.
======================================================================================================
중복 코드를 제거하기 위해 시도할 방법은 타입 코드 사용하기, 상속이 있다.
타입 코드 사용에 단점은 클래스가 낮은 응집도와 높은 결합도 문제에 시달리게 된다.
상속은 객체지향 프로그래밍의 대표하는 기법이며 중복 코드를 관리를 효과적으로 할 수 있다.
======================================================================================================
하지만 상속을 피해야하는 이유가 있다.
1. 자식 클래스 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스가 강하게 결합된다. 
강하게 결합되기 때문에 부모 클래스의 변경의 자식 클래스에게 영향을 주게된다. 이런 현상을 취약한 기반 클래스 문제라고 부른다. 
취약한 기반 클래스 문제는 캡슐화를 약화 시키고 결합도를 높인다. 자식 클래스가 세부사항에 의존하도록 만들었기 때문에 캡슐화를 약화 시킨다. 이것이 상속의 위험한 이유이다. 

객체를 사용하는 이유는 퍼블릭 인터페이스 뒤에 세부사항을 숨기는 캡슐화를 할 수 있기 때문이다. 캡슐화는 변경에 의한 파급효과를 제어할 수 있기 때문에 가치가 있다.
상속을 사용하면 부모 클래스의 구현이 변경되면 자식 클래스의 영향을 받기 쉬워진다. 상속은 코드 재사용으로 캡슐화의 장점을 희석 시키고 구현에 대한 결합도를 높이게된다.

2. 상속 받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
java.util 패키지에 Stack은 Vector가 있다. Stack은 LIFO 자료 구조이고 Vector는 임의이 요소에 저장하고 추출하는 리스트 자료 구조이다.
Stack은 실제로 Vector를 상속받아서 구현되었다. Stack의 퍼블릭 인터페으스에 Vector의 퍼블릭 인터페이스가 합쳐진다.
Stack은 Vector의 퍼블릭 인터페이스로 임의의 위치에 추가, 삭제를 할 수 있다. LIFO의 규칙을 위반하였다.

3. 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.
조슈아 블로치는 이펙티브 자바를 통해서 HashSet의 구현에 강하게 결합된 InstrumentHashSet 클래스를 소개한다.
InstrumentHashSet은 HashSet을 상속받고 add 메서드와 addAll 메서드에 엘리먼트를 저장할 때마다 엘리먼트의 양만큼 숫자를 카운팅하도록 재정의하였다. 
addAll에 3개의 엘리먼트를 추가하면 3을 추가하였지만 실제로는 6이 추가되었다. 그 이유는 addAll이 add를 호출하기 때문이다.

조슈아 블로치는 클래스 상속을 원하면 클래스를 설계화하고 문서화해야 하며, 그렇지 않은 경우에는 상속을 금지시켜야한다고 주장한다.

설계는 트레이트오프 활동이다. 재사용을 원하면 상속을, 캡슐화를 원한다면 상속을 버리고 다른 방법을 사용해야한다.

4. 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.
상속으로 통한 결합으로 오버라이딩하거나 인터페이스를 상속받지 않아도 부모 클래스의 변경이 자식 클래스에게 까지 영향을 미칠 수 있다.
======================================================================================================
상속의 강한 결합 문제는 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해줘야 한다.

중복을 제거하기 위해 두 가지 원칙있다.
1. 두 메서드가 유사하게 보인다면 '차이점을 메서드로 추출하라.' 메서드를 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
2. 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 
부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻는다.

'차이점을 메서드로 추출하라.'는 가장 먼저 할 일은 중복 코드 안에서 메서드로 추출하는 것이다.
'변하는 것으로부터 변하지 않은 것을 분리하라.', '변하는 부분을 찾고 이를 캡슐화하라.'

'중복 코드를 부모 클래스로 올려라.'는 목표는 모든 클래스들이 추상화에 의존하도록 만드는 것이기 때문이다. 

단계별로 정리하면 아래 처럼하면 된다.
1. 각 클래스의 메서드에서 다른 부분을 별도의 메서드로 추출한다.
2. 두 클래스에 완전 동일한 부분을 새로운 부모 클래스로 이동시킨다.
3. 완전 동일한 부분에 필요한 인스턴스를 부모 클래스로 이동시킨다.
4. 처음에 별도로 추출한 메서드를 부모 클래스에 추상 메서드로 선언하고 자식 클래스들이 오버라이딩한다.

A클래스와 B클래스가 공통 부분으로 요금을 계산을 하는 두 개의 클래스를 위에 단계를 통해서 추상화를 한다고 가정한다. 

추상화가 잘 이루어졌다면 A, B 클래스는 부모 클래스의 추상 메서드에만 의존하게 될 것이다.
추상 메서드에만 의존하는 것은 부모 클래스의 내부 구현이 변경되어도 두 자식 클래스에게 영향을 미치지 않을 것이다.
그리고 새로운 요금 계산이 필요하다면 부모 클래스를 상속받는 클래스만 추가해주면 된다.

여기서 부모 클래스의 내부 구현은 A, B클 래스에 의존하지 않고 추상 메서드에 의존한다. 의존성 역전 원칙을 준수하는 것이다.
새로운 요금 계산에 기존 클래스는 변경하지 않고 새로운 클래스만 추가하기 때문에 확장에는 열려있고 수정에는 닫혀있기 때문에 개방-폐쇄 원칙 또한 준수한다.

하지만 상속의 결합도는 사라지지 않는다. 부모 클래스의 인스턴스와 자식 클래스는 결합되어있기 때문에 인스턴스가 추가되거나 삭제되었을 때 변경될 가능성이 높다.

상속의 단점을 피하면서도 코드를 재사용할 수 있는 합성도 있다.
======================================================================================================




